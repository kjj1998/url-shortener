# Workflow to build image of url shortener and deploy to AWS EKS
name: Deploy changes for URL shortener to AWS EKS
run-name: ${{ github.actor }} is deploying changes for URL shortener

# Controls when the action will run. Invokes the workflow on push events but only for the main branch
on:
  push:
    branches: [ main ]
env:
  AWS_REGION : ap-southeast-1 # Change to reflect your Region
  AWS_ACCOUNT_ID: 271407076537 # Change to reflect your AWS Account ID

# Permission can be added at job level or workflow level    
permissions:
      id-token: write   # This is required for requesting the JWT
      contents: read    # This is required for actions/checkout
jobs:
  build_image:
    name: 'Build image of URL shortener'
    runs-on: ubuntu-latest

    defaults:
      run:
        shell: bash
        working-directory: .

    steps:
      - name: Git clone the repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # - name: Get GitHub email
      #   id: get_github_email
      #   run: |
      #     EMAIL=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
      #               -H "Accept: application/vnd.github.v3+json" \
      #               https://api.github.com/user/emails | jq -r '.[0].email')
      #     echo "GitHub registered email: $EMAIL"
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Set up Git user
        run: |
          git config user.name "${GITHUB_ACTOR}"
          git config user.email "koh.jun.jie@outlook.com"

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4.0.1
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/GitHubAction-url-shortener # change to reflect your IAM role’s ARN
          role-session-name: GitHub_to_AWS_via_FederatedOIDC
          aws-region: ${{ env.AWS_REGION }}

      - name: Create .env file
        run: echo "${{ secrets.ENV_FILE }}" > .env

      - name: Get latest tag
        id: get_tag
        run: |
          TAG=$(git describe --tags --abbrev=0)
          echo $TAG
          echo "LATEST_TAG=$TAG" >> $GITHUB_ENV
      
      - name: Increment tag
        id: increment_tag
        run: |
          if [ "${{ env.LATEST_TAG }}" = "v0.0.0" ]; then
            NEW_TAG="v1.0.0"
          else
            BASE_VERSION=$(echo ${{ env.LATEST_TAG }} | sed 's/^v//')
            NEW_TAG="v$(echo $BASE_VERSION | awk -F. '{printf "%d.%d.%d", $1, $2, $3+1}')"
          fi
          echo $NEW_TAG
          echo "NEW_TAG=$NEW_TAG" >> $GITHUB_ENV
      
      - name: Tag the current commit
        id: tag_commit
        run: |
          git tag -a ${{ env.NEW_TAG }} -m "Release version ${{ env.NEW_TAG }}"
          git push origin ${{ env.NEW_TAG }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # - name: Build the Docker image
      #   run: docker build -t url-shortener:0.6.7 .

      # # Hello from AWS: WhoAmI
      # - name: Sts GetCallerIdentity
      #   run: aws sts get-caller-identity

      

      # - name: Authenticate Docker client to AWS ECR
      #   run: aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com && docker tag url-shortener:0.6.7 ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener:0.6.7

      # - name: Tag the Docker image for AWS ECR
      #   run: docker tag url-shortener:0.6.7 ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener:0.6.7

      # - name: Push the tagged image to AWS ECR
      #   run: docker push ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/url-shortener:0.6.7

      # - name: Login to Docker Hub
      #   run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      # - name: Push the Docker image to Docker Hub
      #   run: docker tag url-shortener ${{ secrets.DOCKER_USERNAME }}/url-shortener:latest && docker push ${{ secrets.DOCKER_USERNAME }}/url-shortener:latest

    # steps:
    #   - name: Git clone the repository
    #     uses: actions/checkout@v4

    #   - name: Configure AWS Credentials
    #     uses: aws-actions/configure-aws-credentials@v4.0.1
    #     with:
    #       role-to-assume: arn:aws:iam::271407076537:role/GitHubAction-url-shortener #change to reflect your IAM role’s ARN
    #       role-session-name: GitHub_to_AWS_via_FederatedOIDC
    #       aws-region: ${{ env.AWS_REGION }}
      
    #   # Hello from AWS: WhoAmI
    #   - name: Sts GetCallerIdentity
    #     run: aws sts get-caller-identity

    #   - name: Setup Terraform with specified version on the runner
    #     uses:  hashicorp/setup-terraform@v3.0.0
    #     with:
    #       terraform_version: "1.7.0"
      
    #   # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    #   - name: Terraform init
    #     run: terraform init

    #   # Checks that all Terraform configuration files adhere to a canonical format
    #   - name: Terraform Format
    #     run: terraform fmt -check

    #   # Generates an execution plan for Terraform
    #   - name: Terraform Plan
    #     run: terraform plan -input=false
      
    #   # Test bash script
    #   - name: Test bash script
    #     working-directory: scripts
    #     run: chmod +x ./run.sh && ./run.sh

    #   # On push to "master", build or change infrastructure according to Terraform configuration files
    #   # Note: It is recommended to set up a required "strict" status check in your repository for "Terraform Cloud". See the documentation on "strict" required status checks for more information: https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks
    #   - name: Terraform Apply
    #     run: terraform apply -auto-approve -input=false